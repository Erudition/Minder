module Task.Assignment exposing (..)

import Activity.Activity as Activity exposing (ActivityID)
import Dict exposing (Dict)
import ExtraCodecs as Codec
import ID exposing (ID)
import Incubator.IntDict.Extra as IntDict
import IntDict exposing (IntDict)
import Json.Decode.Exploration as Decode exposing (..)
import Json.Decode.Exploration.Pipeline as Pipeline exposing (..)
import Json.Encode as Encode exposing (..)
import Json.Encode.Extra as Encode2 exposing (..)
import List.Extra
import Log
import Replicated.Change as Change exposing (Change, Changer, Context, getPointerObjectID)
import Replicated.Codec as Codec exposing (Codec, SelfSeededCodec, WrappedCodec)
import Replicated.Op.OpID as OpID exposing (toRonPointerString)
import Replicated.Reducer.Register as Reg exposing (RW, Reg)
import Replicated.Reducer.RepDb as RepDb exposing (RepDb)
import Replicated.Reducer.RepDict as RepDict exposing (RepDict)
import Replicated.Reducer.RepList as RepList exposing (RepList)
import Replicated.Reducer.RepStore as RepStore exposing (RepStore)
import Result.Extra as Result
import SmartTime.Duration exposing (Duration)
import SmartTime.Human.Clock as Clock
import SmartTime.Human.Moment as HumanMoment exposing (FuzzyMoment, Zone)
import SmartTime.Moment exposing (..)
import SmartTime.Period as Period exposing (Period)
import Task.Action exposing (Action, ActionID, ActionSkel, TrackableLayerProperties)
import Task.Assignable exposing (Assignable, AssignableID, AssignableSkel, decodeTaskMoment, encodeTaskMoment)
import Task.Entry as Entry
import Task.Progress as Progress exposing (..)
import Task.Series exposing (Series, SeriesID)
import Task.SessionSkel as Session exposing (UserPlannedSession, decodeSession, encodeSession)
import ZoneHistory exposing (ZoneHistory)



-- Assignment Skeleton (bare minimum, non-derivative data, saved to disk) --------------------------------


{-| Definition of a single assignment of a single task - one particular time that the specific thing will be done, that can be scheduled. Can be thought of as an "assignment" of a task (assignable). There may be zero (an unassigned task), and there may be many (a repeated task) for a given assignable.
-}
type alias AssignmentSkel =
    { assignableID : RW AssignableID
    , memberOfSeries : Maybe SeriesID
    , completion : RW Progress.Portion
    , externalDeadline : RW (Maybe FuzzyMoment) -- *
    , startBy : RW (Maybe FuzzyMoment) -- *
    , finishBy : RW (Maybe FuzzyMoment) -- *
    , plannedSessions : RepList UserPlannedSession
    , relevanceStarts : RW (Maybe FuzzyMoment) -- *
    , relevanceEnds : RW (Maybe FuzzyMoment) -- * (*)=An absolute FuzzyMoment if specified, otherwise generated by relative rules from assignable
    , children : RepStore ActionID (Reg AssignedActionSkel)
    , extra : RepDict String String
    }


codec : Codec String ( AssignableID, Changer (Reg AssignmentSkel) ) Codec.SoloObject (Reg AssignmentSkel)
codec =
    Codec.record AssignmentSkel
        |> Codec.coreRW ( 1, "assignableID" ) .assignableID Codec.id identity
        |> Codec.maybeR ( 2, "memberOfSeries" ) .memberOfSeries Codec.int
        |> Codec.fieldRW ( 3, "completion" ) .completion Codec.int 0
        |> Codec.maybeRW ( 4, "externalDeadline" ) .externalDeadline Codec.fuzzyMoment
        |> Codec.maybeRW ( 5, "startBy" ) .startBy Codec.fuzzyMoment
        |> Codec.maybeRW ( 6, "finishBy" ) .finishBy Codec.fuzzyMoment
        |> Codec.fieldList ( 7, "plannedSessions" ) .plannedSessions Session.codec
        |> Codec.maybeRW ( 8, "relevanceStarts" ) .relevanceStarts Codec.fuzzyMoment
        |> Codec.maybeRW ( 9, "relevanceEnds" ) .relevanceEnds Codec.fuzzyMoment
        |> Codec.fieldStore ( 10, "children" ) .children ( Codec.id, assignedActionCodec )
        |> Codec.fieldDict ( 11, "extra" ) .extra ( Codec.string, Codec.string )
        |> Codec.finishSeededRegister


type alias AssignmentID =
    ID (Reg AssignmentSkel)


type alias AssignmentDb =
    RepDb (Reg AssignmentSkel)


initWithClass : AssignableID -> Context (Reg AssignmentSkel) -> Reg AssignmentSkel
initWithClass actionClassID context =
    Codec.seededNew codec context ( actionClassID, \_ -> [] )


initWithClassAndChanges : AssignableID -> Change.Changer (Reg AssignmentSkel) -> Context (Reg AssignmentSkel) -> Reg AssignmentSkel
initWithClassAndChanges actionClassID changer context =
    Codec.seededNew codec context ( actionClassID, changer )



-- FULL Instances (augmented with Entry & ActionClass) ----------------------------------------


{-| Assignment with metadata
-}
type alias Assignment =
    { parents : List (Reg TrackableLayerProperties)
    , assignable : Reg AssignableSkel
    , assignment : Reg AssignmentSkel
    , index : Int
    , assignmentID : AssignmentID
    , assignableID : AssignableID
    , remove : Change
    }


{-| Get all relevant assignments of everything.

Take the skeleton data and get all relevant(within given time period) assignments of every assignable, and return them as Full Instances.

TODO organize with IDs somehow

-}
listAllAssignments : List Assignable -> AssignmentDb -> ( ZoneHistory, Period ) -> List Assignment
listAllAssignments fullClasses assignmentDb timeData =
    List.concatMap (assignmentsOfAssignable timeData assignmentDb) fullClasses


{-| Take a assignable and return all of the assignments relevant within the given period - saved or generated.

Combine the saved assignments with generated ones, to get the full picture within a period.

TODO: best data structure? Is Dict unnecessary here? Or should the key involve the assignableID for perf?

-}
assignmentsOfAssignable : ( ZoneHistory, Period ) -> AssignmentDb -> Assignable -> List Assignment
assignmentsOfAssignable ( zoneHistory, relevantPeriod ) assignmentDb fullAssignable =
    let
        savedInstancesWithMatchingClass =
            List.filter (\member -> (Reg.latest member.value).assignableID.get == fullAssignable.assignableID) (RepDb.members assignmentDb)

        savedInstancesFull =
            List.indexedMap toFull savedInstancesWithMatchingClass

        toFull : Int -> RepDb.Member (Reg AssignmentSkel) -> Assignment
        toFull indexFromZero assignmentSkelMember =
            { parents = fullAssignable.parents
            , assignable = fullAssignable.assignable
            , assignment = assignmentSkelMember.value
            , index = indexFromZero + 1
            , assignmentID = assignmentSkelMember.id
            , assignableID = fullAssignable.assignableID
            , remove = assignmentSkelMember.remove
            }

        -- Filter out assignments outside the window
        relevantSavedInstances =
            List.filter isRelevant savedInstancesFull

        -- TODO "If savedInstance is within period, keep"
        isRelevant savedInstance =
            True

        -- TODO Fill in based on recurrence series. Int ID = order in series.
        relevantSeriesMembers =
            fillSeries ( zoneHistory, relevantPeriod ) fullAssignable
    in
    relevantSavedInstances


{-| Get all relevant actions of all assignments.
-}
listAllActions : List Assignable -> AssignmentDb -> ( ZoneHistory, Period ) -> List AssignedAction
listAllActions assignables assignmentDb timeData =
    let
        allAssignments =
            listAllAssignments assignables assignmentDb timeData
    in
    List.concatMap (actionsOfAssignment timeData) allAssignments


{-| -}
actionsOfAssignment : ( ZoneHistory, Period ) -> Assignment -> List AssignedAction
actionsOfAssignment ( zoneHistory, relevantPeriod ) assignment =
    let
        actions =
            Entry.assignableToActions assignment.parents assignment.assignable

        assignedActionsWithClassID =
            (Reg.latest assignment.assignment).children

        fullAssignmentFromAction : Action -> AssignedAction
        fullAssignmentFromAction action =
            let
                assignedAction =
                    RepStore.get action.actionID assignedActionsWithClassID

                assignedActionSkel =
                    Reg.latest assignedAction
            in
            { parents = action.parents
            , action = action.action
            , actionID = action.actionID
            , assignable = assignment.assignable
            , assignment = assignment.assignment
            , assignmentID = assignment.assignmentID
            , assignableID = assignment.assignableID
            , assignedAction = assignedAction
            }

        fullAssignmentsFromActions : List AssignedAction
        fullAssignmentsFromActions =
            List.map fullAssignmentFromAction actions

        -- Filter out assignments outside the window
        relevantSavedActionAssignments =
            List.filter isRelevant fullAssignmentsFromActions

        -- TODO "If savedInstance is within period, keep"
        isRelevant savedInstance =
            True
    in
    relevantSavedActionAssignments


fillSeries : ( ZoneHistory, Period ) -> Assignable -> List Assignment
fillSeries ( zoneHistory, relevantPeriod ) fullAssignable =
    -- TODO
    []



-- Task helper functions ---------------------------------------------


isRelevantNow : Assignment -> Moment -> Zone -> Bool
isRelevantNow assignment now zone =
    let
        fuzzyNow =
            HumanMoment.Global now

        start =
            Maybe.withDefault fuzzyNow (Reg.latest assignment.assignment).relevanceStarts.get

        end =
            Maybe.withDefault fuzzyNow (Reg.latest assignment.assignment).relevanceEnds.get

        notBeforeStart =
            HumanMoment.compareFuzzy zone Clock.startOfDay fuzzyNow start /= Earlier

        notAfterEnd =
            HumanMoment.compareFuzzy zone Clock.endOfDay fuzzyNow end /= Later
    in
    notBeforeStart && notAfterEnd


completed : Assignment -> Bool
completed assignment =
    isMax ( (Reg.latest assignment.assignment).completion.get, (Reg.latest assignment.assignable).completionUnits.get )


partiallyCompleted : Assignment -> Bool
partiallyCompleted assignment =
    (Reg.latest assignment.assignment).completion.get > 0


type alias WithSoonness t =
    { t | soonness : Duration }


prioritize : Moment -> HumanMoment.Zone -> List Assignment -> List Assignment
prioritize now zone taskList =
    let
        -- lowest values first
        compareProp prop a b =
            Basics.compare (prop a) (prop b)

        -- highest values first
        comparePropInverted prop a b =
            Basics.compare (prop b) (prop a)
    in
    -- deepSort [ compareSoonness zone, comparePropInverted .importance ] taskList
    deepSort [ compareSoonness zone, compareNewness ] taskList



-- List.sortWith (compareSoonness zone) <| List.sortBy .importance taskList


type alias CompareFunction a =
    a -> a -> Basics.Order


deepSort : List (CompareFunction a) -> List a -> List a
deepSort compareFuncs listToSort =
    let
        deepCompare funcs a b =
            case funcs of
                [] ->
                    -- No more comparisons to make, give up and say they're equal
                    EQ

                nextCompareFunc :: laterCompareFuncs ->
                    let
                        -- run next comparison
                        check =
                            nextCompareFunc a b
                    in
                    if check == EQ then
                        -- they still look equal, dig deeper
                        deepCompare laterCompareFuncs a b

                    else
                        -- we have a winner, we can stop digging
                        check
    in
    List.sortWith (deepCompare compareFuncs) listToSort


{-| TODO this could be a Moment.Fuzzy function
-}
compareSoonness : HumanMoment.Zone -> CompareFunction Assignment
compareSoonness zone taskA taskB =
    case ( (Reg.latest taskA.assignment).externalDeadline.get, (Reg.latest taskB.assignment).externalDeadline.get ) of
        ( Just fuzzyMomentA, Just fuzzyMomentB ) ->
            HumanMoment.compareFuzzyLateness zone Clock.endOfDay fuzzyMomentA fuzzyMomentB

        ( Nothing, Nothing ) ->
            -- whenevers can't be compared
            EQ

        ( Just _, Nothing ) ->
            -- actual times always come before whenevers
            LT

        ( Nothing, Just _ ) ->
            -- whenevers always come after actual times
            GT


compareNewness : CompareFunction Assignment
compareNewness taskA taskB =
    let
        taskToIDString task =
            task.assignment
                |> Reg.getPointer
                |> Change.getPointerObjectID
                |> Maybe.map OpID.toString
                |> Maybe.withDefault ""
    in
    Basics.compare (taskToIDString taskB) (taskToIDString taskA)


getID : Assignment -> AssignmentID
getID ins =
    ins.assignmentID


getIDString : Assignment -> String
getIDString ins =
    ID.toString ins.assignmentID


getClassIDString : Assignment -> String
getClassIDString ins =
    ID.toString ins.assignableID


getTitle : Assignment -> String
getTitle assignment =
    (Reg.latest assignment.assignable).title.get


getActivityID : Assignment -> Maybe ActivityID
getActivityID assignment =
    (Reg.latest assignment.assignable).activity.get


getActivityIDString : Assignment -> Maybe String
getActivityIDString assignment =
    Maybe.map Activity.idToString (Reg.latest assignment.assignable).activity.get


getProgress : Assignment -> Progress
getProgress assignment =
    ( (Reg.latest assignment.assignment).completion.get, (Reg.latest assignment.assignable).completionUnits.get )


setCompletion : Portion -> Assignment -> Change
setCompletion newPortion assignment =
    (Reg.latest assignment.assignment).completion.set newPortion


setProjectTitle : String -> Assignment -> Change
setProjectTitle newTitle assignment =
    (Reg.latest assignment.assignable).title.set newTitle


getProgressMaxInt : Assignment -> Portion
getProgressMaxInt assignment =
    Progress.unitMax (Reg.latest assignment.assignable).completionUnits.get


getCompletionInt : Assignment -> Int
getCompletionInt assignment =
    (Reg.latest assignment.assignment).completion.get


getImportance : Assignment -> Float
getImportance assignment =
    (Reg.latest assignment.assignable).importance.get


setImportance : Assignment -> Float -> Change
setImportance assignment =
    (Reg.latest assignment.assignable).importance.set


getRelevanceStarts : Assignment -> Maybe FuzzyMoment
getRelevanceStarts assignment =
    (Reg.latest assignment.assignment).relevanceStarts.get


getRelevanceEnds : Assignment -> Maybe FuzzyMoment
getRelevanceEnds assignment =
    (Reg.latest assignment.assignment).relevanceEnds.get


getExternalDeadline : Assignment -> Maybe FuzzyMoment
getExternalDeadline assignment =
    (Reg.latest assignment.assignment).externalDeadline.get


getMinEffort : Assignment -> Duration
getMinEffort assignment =
    (Reg.latest assignment.assignable).minEffort.get


getEstimatedEffort : Assignment -> Duration
getEstimatedEffort assignment =
    (Reg.latest assignment.assignable).predictedEffort.get


setEstimatedEffort : Assignment -> Duration -> Change
setEstimatedEffort assignment =
    (Reg.latest assignment.assignable).predictedEffort.set


getMaxEffort : Assignment -> Duration
getMaxEffort assignment =
    (Reg.latest assignment.assignable).maxEffort.get


getExtra : String -> Assignment -> Maybe String
getExtra key assignment =
    RepDict.get key (Reg.latest assignment.assignment).extra


setExtra : String -> String -> Assignment -> Change
setExtra key value assignment =
    RepDict.insert key value (Reg.latest assignment.assignment).extra


deleteAssignment : Assignment -> Change
deleteAssignment assignment =
    assignment.remove



-- AssignedAction Skeleton (bare minimum, non-derivative data, saved to disk) --------------------------------


{-| Definition of a single action of a single assignment of a single task
-}
type alias AssignedActionSkel =
    { completion : RW Progress.Portion
    , externalDeadline : RW (Maybe FuzzyMoment)
    , startBy : RW (Maybe FuzzyMoment)
    , finishBy : RW (Maybe FuzzyMoment)
    , plannedSessions : RepList UserPlannedSession
    , relevanceStarts : RW (Maybe FuzzyMoment)
    , relevanceEnds : RW (Maybe FuzzyMoment)
    , extra : RepDict String String
    }


assignedActionCodec : WrappedCodec String (Reg AssignedActionSkel)
assignedActionCodec =
    Codec.record AssignedActionSkel
        |> Codec.fieldRW ( 3, "completion" ) .completion Codec.int 0
        |> Codec.maybeRW ( 4, "externalDeadline" ) .externalDeadline Codec.fuzzyMoment
        |> Codec.maybeRW ( 5, "startBy" ) .startBy Codec.fuzzyMoment
        |> Codec.maybeRW ( 6, "finishBy" ) .finishBy Codec.fuzzyMoment
        |> Codec.fieldList ( 7, "plannedSessions" ) .plannedSessions Session.codec
        |> Codec.maybeRW ( 8, "relevanceStarts" ) .relevanceStarts Codec.fuzzyMoment
        |> Codec.maybeRW ( 9, "relevanceEnds" ) .relevanceEnds Codec.fuzzyMoment
        |> Codec.fieldDict ( 10, "extra" ) .extra ( Codec.string, Codec.string )
        |> Codec.finishRegister


type alias AssignedActionID =
    ID (Reg AssignedActionSkel)



-- FULL Assigned Actions (augmented with Project and Assignment) ----------------------------------------


{-| Assignment Action with metadata
-}
type alias AssignedAction =
    { parents : List (Reg TrackableLayerProperties)
    , action : Reg ActionSkel
    , assignedAction : Reg AssignedActionSkel
    , assignable : Reg AssignableSkel
    , assignment : Reg AssignmentSkel
    , assignmentID : AssignmentID
    , assignableID : AssignableID
    , actionID : ActionID
    }



-- Task helper functions ---------------------------------------------


isActionRelevantNow : AssignedAction -> Moment -> Zone -> Bool
isActionRelevantNow assignedAction now zone =
    let
        fuzzyNow =
            HumanMoment.Global now

        start =
            Maybe.withDefault fuzzyNow (Reg.latest assignedAction.assignedAction).relevanceStarts.get

        end =
            Maybe.withDefault fuzzyNow (Reg.latest assignedAction.assignedAction).relevanceEnds.get

        notBeforeStart =
            HumanMoment.compareFuzzy zone Clock.startOfDay fuzzyNow start /= Earlier

        notAfterEnd =
            HumanMoment.compareFuzzy zone Clock.endOfDay fuzzyNow end /= Later
    in
    notBeforeStart && notAfterEnd


actionCompleted : AssignedAction -> Bool
actionCompleted assignedAction =
    isMax ( (Reg.latest assignedAction.assignedAction).completion.get, (Reg.latest assignedAction.action).completionUnits.get )


actionPartiallyCompleted : AssignedAction -> Bool
actionPartiallyCompleted assignedAction =
    (Reg.latest assignedAction.assignedAction).completion.get > 0


actionGetTitle : AssignedAction -> String
actionGetTitle assignedAction =
    (Reg.latest assignedAction.action).title.get


actionGetActivityID : AssignedAction -> Maybe ActivityID
actionGetActivityID assignedAction =
    (Reg.latest assignedAction.action).activity.get


actionGetActivityIDString : AssignedAction -> Maybe String
actionGetActivityIDString assignedAction =
    Maybe.map Activity.idToString (Reg.latest assignedAction.action).activity.get


actionGetProgress : AssignedAction -> Progress
actionGetProgress assignedAction =
    ( (Reg.latest assignedAction.assignedAction).completion.get, (Reg.latest assignedAction.action).completionUnits.get )


actionSetCompletion : Portion -> AssignedAction -> Change
actionSetCompletion newPortion assignedAction =
    (Reg.latest assignedAction.assignedAction).completion.set newPortion


actionSetProjectTitle : String -> AssignedAction -> Change
actionSetProjectTitle newTitle assignedAction =
    (Reg.latest assignedAction.action).title.set newTitle


actionGetProgressMaxInt : AssignedAction -> Portion
actionGetProgressMaxInt assignedAction =
    Progress.unitMax (Reg.latest assignedAction.action).completionUnits.get


actionGetCompletionInt : AssignedAction -> Int
actionGetCompletionInt assignedAction =
    (Reg.latest assignedAction.assignedAction).completion.get


actionSetImportance : AssignedAction -> Float -> Change
actionSetImportance assignedAction =
    (Reg.latest assignedAction.assignable).importance.set


actionGetRelevanceStarts : AssignedAction -> Maybe FuzzyMoment
actionGetRelevanceStarts assignedAction =
    (Reg.latest assignedAction.assignedAction).relevanceStarts.get


actionGetRelevanceEnds : AssignedAction -> Maybe FuzzyMoment
actionGetRelevanceEnds assignedAction =
    (Reg.latest assignedAction.assignedAction).relevanceEnds.get


actionGetExternalDeadline : AssignedAction -> Maybe FuzzyMoment
actionGetExternalDeadline assignedAction =
    (Reg.latest assignedAction.assignedAction).externalDeadline.get


actionGetMinEffort : AssignedAction -> Duration
actionGetMinEffort assignedAction =
    (Reg.latest assignedAction.action).minEffort.get


actionGetEstimatedEffort : AssignedAction -> Duration
actionGetEstimatedEffort assignedAction =
    (Reg.latest assignedAction.action).predictedEffort.get


actionSetEstimatedEffort : AssignedAction -> Duration -> Change
actionSetEstimatedEffort assignedAction =
    (Reg.latest assignedAction.action).predictedEffort.set


actionGetMaxEffort : AssignedAction -> Duration
actionGetMaxEffort assignedAction =
    (Reg.latest assignedAction.action).maxEffort.get


actionGetExtra : String -> AssignedAction -> Maybe String
actionGetExtra key assignedAction =
    RepDict.get key (Reg.latest assignedAction.assignedAction).extra


actionSetExtra : String -> String -> AssignedAction -> Change
actionSetExtra key value assignedAction =
    RepDict.insert key value (Reg.latest assignedAction.assignedAction).extra
